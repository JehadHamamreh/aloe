<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ALOE++ OESR API: /home/ismael/aloe_ws/aloe_git/oesr/include/oesr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ALOE++ OESR API
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2f0b00c0211dbf39711c0bf44f1d68b1.html">oesr</a></li><li class="navelem"><a class="el" href="dir_cf6406bfdd6111f013470fc58e10e89d.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">oesr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;oesr_types.h&quot;</code><br/>
</div>
<p><a href="oesr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9c80a94553b05c8132ad1351bcf65658"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oesr_8h.html#a9c80a94553b05c8132ad1351bcf65658">OESR_ITF_DEFAULT_MSG</a>&#160;&#160;&#160;50</td></tr>
<tr class="memitem:ga04b1b3ca21047be3cf86c378286cdf57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error.html#ga04b1b3ca21047be3cf86c378286cdf57">oesr_perror</a>(msg)&#160;&#160;&#160;<a class="el" href="group__error.html#ga21c27a09f22f8430c080486a25195029">oesr_error_print</a>(ctx,&quot;&quot;); aerror(msg)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga54ee68c74558908e8e7f827936deb307"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__functions.html#ga54ee68c74558908e8e7f827936deb307">Run</a> (void *context)</td></tr>
<tr class="memdesc:ga54ee68c74558908e8e7f827936deb307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 0 on success or -1 to stop the waveform.  <a href="group__module__functions.html#ga54ee68c74558908e8e7f827936deb307"></a><br/></td></tr>
<tr class="memitem:gafa75b8b72ccbb6e99c353ca34ab1272e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__functions.html#gafa75b8b72ccbb6e99c353ca34ab1272e">Init</a> (void *context)</td></tr>
<tr class="memdesc:gafa75b8b72ccbb6e99c353ca34ab1272e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 on success, 0 to be called in the next timeslot or -1 to stop the waveform.  <a href="group__module__functions.html#gafa75b8b72ccbb6e99c353ca34ab1272e"></a><br/></td></tr>
<tr class="memitem:ga48740506cf522a6cbcc6ac564327cf9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__functions.html#ga48740506cf522a6cbcc6ac564327cf9f">Stop</a> (void *context)</td></tr>
<tr class="memdesc:ga48740506cf522a6cbcc6ac564327cf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 0 on success or -1 on error.  <a href="group__module__functions.html#ga48740506cf522a6cbcc6ac564327cf9f"></a><br/></td></tr>
<tr class="memitem:ga96241ad0cc82628558e79f319263d738"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error.html#ga96241ad0cc82628558e79f319263d738">oesr_error_code</a> (void *ctx)</td></tr>
<tr class="memitem:ga21c27a09f22f8430c080486a25195029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error.html#ga21c27a09f22f8430c080486a25195029">oesr_error_print</a> (void *context, const char *user_message)</td></tr>
<tr class="memitem:gaa11b36e80f21f276ff03783227f8b0c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gaa11b36e80f21f276ff03783227f8b0c9">oesr_tstamp</a> (void *context)</td></tr>
<tr class="memdesc:gaa11b36e80f21f276ff03783227f8b0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the module's timestamp. This is the number of timeslots that the object has executed the INIT an RUN states. This function is always successful.  <a href="group__base.html#gaa11b36e80f21f276ff03783227f8b0c9"></a><br/></td></tr>
<tr class="memitem:gab72fbe047f8794d2a9a458cfce7509d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gab72fbe047f8794d2a9a458cfce7509d6">oesr_tslot_length</a> (void *context)</td></tr>
<tr class="memitem:ga80078711483d249618c55331061fe8d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga80078711483d249618c55331061fe8d5">oesr_exit</a> (void *context)</td></tr>
<tr class="memdesc:ga80078711483d249618c55331061fe8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the calling module execution. Sets the module as NON-runnable.  <a href="group__base.html#ga80078711483d249618c55331061fe8d5"></a><br/></td></tr>
<tr class="memitem:ga11dbee400724229ebd7870653e02bba9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga11dbee400724229ebd7870653e02bba9">oesr_module_name</a> (void *context)</td></tr>
<tr class="memdesc:ga11dbee400724229ebd7870653e02bba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the oesr name string.  <a href="group__base.html#ga11dbee400724229ebd7870653e02bba9"></a><br/></td></tr>
<tr class="memitem:gafc3984482b5a92e69c54a9a6043bc5dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gafc3984482b5a92e69c54a9a6043bc5dc">oesr_module_id</a> (void *context)</td></tr>
<tr class="memdesc:gafc3984482b5a92e69c54a9a6043bc5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the module id (non-negative integer), -1 on error.  <a href="group__base.html#gafc3984482b5a92e69c54a9a6043bc5dc"></a><br/></td></tr>
<tr class="memitem:ga928f9703d5a3ce8da83bc98880cb1343"><td class="memItemLeft" align="right" valign="top">itf_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#ga928f9703d5a3ce8da83bc98880cb1343">oesr_itf_create</a> (void *context, int port_idx, oesr_itf_mode_t mode, int size)</td></tr>
<tr class="memdesc:ga928f9703d5a3ce8da83bc98880cb1343"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface is used by modules to exchange data packets (with samples) asynchronously.  <a href="group__itf.html#ga928f9703d5a3ce8da83bc98880cb1343"></a><br/></td></tr>
<tr class="memitem:ga8ef4df01532194c90b85149429c7680d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#ga8ef4df01532194c90b85149429c7680d">oesr_itf_close</a> (itf_t itf)</td></tr>
<tr class="memdesc:ga8ef4df01532194c90b85149429c7680d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__itf.html#ga8ef4df01532194c90b85149429c7680d" title="The oesr_itf_close() function closes an interface previously created by oesr_itf_create(). The interface shall not be used again after calling this function.">oesr_itf_close()</a> function closes an interface previously created by <a class="el" href="group__itf.html#ga928f9703d5a3ce8da83bc98880cb1343" title="An interface is used by modules to exchange data packets (with samples) asynchronously.">oesr_itf_create()</a>. The interface shall not be used again after calling this function.  <a href="group__itf.html#ga8ef4df01532194c90b85149429c7680d"></a><br/></td></tr>
<tr class="memitem:gab01376afdd65f1b4e9ea04584e79705b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#gab01376afdd65f1b4e9ea04584e79705b">oesr_itf_write</a> (itf_t itf, void *buffer, int size)</td></tr>
<tr class="memdesc:gab01376afdd65f1b4e9ea04584e79705b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__itf.html#gab01376afdd65f1b4e9ea04584e79705b" title="oesr_itf_write() copies size bytes of the memory pointed by buffer to a packet which is sent through ...">oesr_itf_write()</a> copies size bytes of the memory pointed by buffer to a packet which is sent through the interface. If size is larger than the size used in <a class="el" href="group__itf.html#ga928f9703d5a3ce8da83bc98880cb1343" title="An interface is used by modules to exchange data packets (with samples) asynchronously.">oesr_itf_create()</a>, no data is copied and -1 is returned. If there is not enough space in the interface to send the packet, 0 is returned. When the function returns, the user may overwrite the contents of the memory pointed by buffer.  <a href="group__itf.html#gab01376afdd65f1b4e9ea04584e79705b"></a><br/></td></tr>
<tr class="memitem:ga43e3b33e38b8fca4bcec601f083a71fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#ga43e3b33e38b8fca4bcec601f083a71fb">oesr_itf_read</a> (itf_t itf, void *buffer, int size)</td></tr>
<tr class="memdesc:ga43e3b33e38b8fca4bcec601f083a71fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__itf.html#ga43e3b33e38b8fca4bcec601f083a71fb" title="oesr_itf_read() copies up to size bytes of the memory pointed by buffer from the packet received from...">oesr_itf_read()</a> copies up to size bytes of the memory pointed by buffer from the packet received from the interface. If size is smaller than the received packet length, only size bytes will be copied. If no packet is pending in the interface, zero is returned.  <a href="group__itf.html#ga43e3b33e38b8fca4bcec601f083a71fb"></a><br/></td></tr>
<tr class="memitem:ga5a955fed4a85add4824cd2966e742124"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#ga5a955fed4a85add4824cd2966e742124">oesr_itf_status</a> (itf_t itf)</td></tr>
<tr class="memdesc:ga5a955fed4a85add4824cd2966e742124"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__itf.html#ga5a955fed4a85add4824cd2966e742124" title="oesr_itf_status() returns the number of bytes pending in the interface.">oesr_itf_status()</a> returns the number of bytes pending in the interface.  <a href="group__itf.html#ga5a955fed4a85add4824cd2966e742124"></a><br/></td></tr>
<tr class="memitem:ga7a7c53b325a1a904682d4ffc07771f06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#ga7a7c53b325a1a904682d4ffc07771f06">oesr_itf_ptr_request</a> (itf_t itf, void **ptr)</td></tr>
<tr class="memdesc:ga7a7c53b325a1a904682d4ffc07771f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a pointer for zero-copy interface utilization.  <a href="group__itf.html#ga7a7c53b325a1a904682d4ffc07771f06"></a><br/></td></tr>
<tr class="memitem:ga3275f85a616402b3108ad418ef0bc5ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#ga3275f85a616402b3108ad418ef0bc5ea">oesr_itf_ptr_release</a> (itf_t itf)</td></tr>
<tr class="memdesc:ga3275f85a616402b3108ad418ef0bc5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a pointer received using <a class="el" href="group__itf.html#gab57a810a4e00dd0ed18fb667c430f701" title="Receives a buffer from an interface.">oesr_itf_ptr_get()</a> after the contents have been processed.  <a href="group__itf.html#ga3275f85a616402b3108ad418ef0bc5ea"></a><br/></td></tr>
<tr class="memitem:gade3bcfe877fdebce50643e692240e62d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#gade3bcfe877fdebce50643e692240e62d">oesr_itf_ptr_put</a> (itf_t itf, int len)</td></tr>
<tr class="memdesc:gade3bcfe877fdebce50643e692240e62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a buffer obtained by <a class="el" href="group__itf.html#ga7a7c53b325a1a904682d4ffc07771f06" title="Requests a pointer for zero-copy interface utilization.">oesr_itf_ptr_request()</a> after the samples have been written to it.  <a href="group__itf.html#gade3bcfe877fdebce50643e692240e62d"></a><br/></td></tr>
<tr class="memitem:gab57a810a4e00dd0ed18fb667c430f701"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__itf.html#gab57a810a4e00dd0ed18fb667c430f701">oesr_itf_ptr_get</a> (itf_t itf, void **ptr, int *len)</td></tr>
<tr class="memdesc:gab57a810a4e00dd0ed18fb667c430f701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a buffer from an interface.  <a href="group__itf.html#gab57a810a4e00dd0ed18fb667c430f701"></a><br/></td></tr>
<tr class="memitem:ga15698f3ab826d6d20ccb2fde7bc905fc"><td class="memItemLeft" align="right" valign="top">var_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__var.html#ga15698f3ab826d6d20ccb2fde7bc905fc">oesr_var_create</a> (void *context, char *name, void *ptr, int size)</td></tr>
<tr class="memitem:ga82a201ed0020d45d3a7bb097774c33fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__var.html#ga82a201ed0020d45d3a7bb097774c33fe">oesr_var_close</a> (void *context, var_t var)</td></tr>
<tr class="memdesc:ga82a201ed0020d45d3a7bb097774c33fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a variable handler. After a call to this function, ALOE can not access to this variable anymore. However, the module may still use the contents of the memory address passed as a parameter in the <a class="el" href="group__var.html#ga15698f3ab826d6d20ccb2fde7bc905fc">oesr_var_create()</a> function.  <a href="group__var.html#ga82a201ed0020d45d3a7bb097774c33fe"></a><br/></td></tr>
<tr class="memitem:ga15942dcaa59766052d7e383e49487ad3"><td class="memItemLeft" align="right" valign="top">var_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__var.html#ga15942dcaa59766052d7e383e49487ad3">oesr_var_param_get</a> (void *context, char *name)</td></tr>
<tr class="memdesc:ga15942dcaa59766052d7e383e49487ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handler for the parameter with name "name". This handler is then used by the functions <a class="el" href="group__var.html#ga05296091361ad9e440617000e1c22e2f" title="Sets up to size bytes of the buffer pointed by ptr to the value of the parameter returned by oesr_var...">oesr_var_param_value()</a> and <a class="el" href="group__var.html#gaf56dedd1bf2f5fc703b2597814388e72" title="Returns the parameter variable type.">oesr_var_param_type()</a>  <a href="group__var.html#ga15942dcaa59766052d7e383e49487ad3"></a><br/></td></tr>
<tr class="memitem:ga05296091361ad9e440617000e1c22e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__var.html#ga05296091361ad9e440617000e1c22e2f">oesr_var_param_value</a> (void *context, var_t parameter, void *value, int size)</td></tr>
<tr class="memdesc:ga05296091361ad9e440617000e1c22e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up to size bytes of the buffer pointed by ptr to the value of the parameter returned by <a class="el" href="group__var.html#ga15942dcaa59766052d7e383e49487ad3" title="Returns a handler for the parameter with name &quot;name&quot;. This handler is then used by the functions oesr...">oesr_var_param_get()</a> On success, returns a non-negative integer indicating the number of bytes written to value.  <a href="group__var.html#ga05296091361ad9e440617000e1c22e2f"></a><br/></td></tr>
<tr class="memitem:gaf56dedd1bf2f5fc703b2597814388e72"><td class="memItemLeft" align="right" valign="top">oesr_var_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__var.html#gaf56dedd1bf2f5fc703b2597814388e72">oesr_var_param_type</a> (void *context, var_t parameter)</td></tr>
<tr class="memdesc:gaf56dedd1bf2f5fc703b2597814388e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parameter variable type.  <a href="group__var.html#gaf56dedd1bf2f5fc703b2597814388e72"></a><br/></td></tr>
<tr class="memitem:ga41e5302d08f95e87cc244cd83d5fc4b2"><td class="memItemLeft" align="right" valign="top">counter_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__counter.html#ga41e5302d08f95e87cc244cd83d5fc4b2">oesr_counter_create</a> (void *context, char *name)</td></tr>
<tr class="memitem:ga2ad0a5f4af1a04468be2c2eceb78fe42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__counter.html#ga2ad0a5f4af1a04468be2c2eceb78fe42">oesr_counter_close</a> (counter_t counter)</td></tr>
<tr class="memdesc:ga2ad0a5f4af1a04468be2c2eceb78fe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter shall be used by a user to measure time intervals. <a class="el" href="group__counter.html#ga41e5302d08f95e87cc244cd83d5fc4b2">oesr_counter_create()</a> returns a counter_t object which is passed as a first parameter to <a class="el" href="group__counter.html#ga1b3a3d1f1126a8ec8ca914b36829f656" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_start()</a> and <a class="el" href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_stop()</a> functions, which start and stop the counter, respectively. A counter is associated with a public module variable which can be accessed from the oesr_man interface. The variable value is updated during a call to <a class="el" href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_stop()</a>, saving the elapsed time between successive calls to start() and stop(), in microseconds.  <a href="group__counter.html#ga2ad0a5f4af1a04468be2c2eceb78fe42"></a><br/></td></tr>
<tr class="memitem:ga1b3a3d1f1126a8ec8ca914b36829f656"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__counter.html#ga1b3a3d1f1126a8ec8ca914b36829f656">oesr_counter_start</a> (counter_t counter)</td></tr>
<tr class="memdesc:ga1b3a3d1f1126a8ec8ca914b36829f656"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter shall be used by a user to measure time intervals. <a class="el" href="group__counter.html#ga41e5302d08f95e87cc244cd83d5fc4b2">oesr_counter_create()</a> returns a counter_t object which is passed as a first parameter to <a class="el" href="group__counter.html#ga1b3a3d1f1126a8ec8ca914b36829f656" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_start()</a> and <a class="el" href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_stop()</a> functions, which start and stop the counter, respectively. A counter is associated with a public module variable which can be accessed from the oesr_man interface. The variable value is updated during a call to <a class="el" href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_stop()</a>, saving the elapsed time between successive calls to start() and stop(), in microseconds. *.  <a href="group__counter.html#ga1b3a3d1f1126a8ec8ca914b36829f656"></a><br/></td></tr>
<tr class="memitem:ga0fa96946aba4cdd7bdc5829111fb94b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5">oesr_counter_stop</a> (counter_t counter)</td></tr>
<tr class="memdesc:ga0fa96946aba4cdd7bdc5829111fb94b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter shall be used by a user to measure time intervals. <a class="el" href="group__counter.html#ga41e5302d08f95e87cc244cd83d5fc4b2">oesr_counter_create()</a> returns a counter_t object which is passed as a first parameter to <a class="el" href="group__counter.html#ga1b3a3d1f1126a8ec8ca914b36829f656" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_start()</a> and <a class="el" href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_stop()</a> functions, which start and stop the counter, respectively. A counter is associated with a public module variable which can be accessed from the oesr_man interface. The variable value is updated during a call to <a class="el" href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5" title="A counter shall be used by a user to measure time intervals. oesr_counter_create() returns a counter_...">oesr_counter_stop()</a>, saving the elapsed time between successive calls to start() and stop(), in microseconds. *.  <a href="group__counter.html#ga0fa96946aba4cdd7bdc5829111fb94b5"></a><br/></td></tr>
<tr class="memitem:gaf8cb9050113138c52dba7b853f95311d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__counter.html#gaf8cb9050113138c52dba7b853f95311d">oesr_counter_usec</a> (counter_t counter)</td></tr>
<tr class="memitem:gae82c028afa07e2d535c1784be270c89d"><td class="memItemLeft" align="right" valign="top">log_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#gae82c028afa07e2d535c1784be270c89d">oesr_log_create</a> (void *context, char *name)</td></tr>
<tr class="memitem:gaf9b505cfb69aac32446acc3918d97ba0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#gaf9b505cfb69aac32446acc3918d97ba0">oesr_log_close</a> (log_t log)</td></tr>
<tr class="memdesc:gaf9b505cfb69aac32446acc3918d97ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a log associated to the handler passed as parameter.  <a href="group__log.html#gaf9b505cfb69aac32446acc3918d97ba0"></a><br/></td></tr>
<tr class="memitem:ga525d34709c8290a1a5da99ae6fc298f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#ga525d34709c8290a1a5da99ae6fc298f2">oesr_log_write</a> (log_t log, char *str)</td></tr>
<tr class="memitem:ga72e99558a708d79d3eed3bb62e94ca93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#ga72e99558a708d79d3eed3bb62e94ca93">oesr_log_printf</a> (log_t log, const char *fmt,...)</td></tr>
<tr class="memdesc:ga72e99558a708d79d3eed3bb62e94ca93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a formated string to the log file associated to the handler log.  <a href="group__log.html#ga72e99558a708d79d3eed3bb62e94ca93"></a><br/></td></tr>
</table>
<h2>Macro Definition Documentation</h2>
<a class="anchor" id="a9c80a94553b05c8132ad1351bcf65658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OESR_ITF_DEFAULT_MSG&#160;&#160;&#160;50</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 9 2012 15:22:43 for ALOE++ OESR API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
